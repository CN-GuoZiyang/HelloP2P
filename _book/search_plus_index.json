{"./":{"url":"./","title":"摘要","keywords":"","body":"Introduction "},"chapter1.html":{"url":"chapter1.html","title":"第一章 概述","keywords":"","body":"第一章 概述 1.1 Hello简介 hello.c文件以ascii码的形式将C语言代码存在磁盘或固态硬盘上。C预处理器（cpp）首先将hello.c文件翻译成ascii码的预处理文件hello.i。在预处理文件中包含着一些头文件的路径以及宏定义等。接着，C编译器（cc1）将hello.i翻译成ascii存储等汇编语言文件hello.s。然后，汇编器（as）将hello.s翻译成一个二进制形式的可重定位目标文件hello.o，可重定位目标文件hello.o中包含有二进制的代码和数据。最后，链接器程序（ld）将hello.o与其它.o文件（如果有的话）以及系统的目标文件链接起来，生成二进制的可执行目标文件hello。用户通过壳（shell）输入运行hello的命令，shell解析该命令之后，fork出一个子进程，在该子进程中调用execve以运行hello。 内核调用系统函数mmap函数将磁盘（硬盘）文件映射到进程的虚拟内存空间。接着进程开始逐步对这片映射空间进行访问，引发缺页异常，逐步将文件中内容拷贝到主存。CPU将虚拟内存地址发送给内存管理单元（MMU），MMU向主存中常驻的页表请求对应的物理地址，并将该物理地址发送给主存，主存取出数据返回给CPU。翻译后备缓冲器（TLB）加速了这一过程。由于数据量较大，页表分为四级，通常只有一级页表常驻主存，剩下的都存在磁盘上。处理器开始逐句逐句取指、译码、执行，并且在多进程的情况下进行分时管理。如果遇到要对磁盘数据进行操作，处理器会首先向最高级缓存请求，如果命中直接返回，如果不命中则向下级缓存请求直到命中为止，接着再逐级写回（必要时驱逐）。如遇到要对磁盘或者输入输出流进行操作，则此时产生了一个异常，操作系统向hello进程发送一个信号，使其暂时挂起，执行异常处理程序，并进入内核模式，执行上下文切换操作切换至其它进程执行，直到对磁盘或者IO的操作结束后，操作系统又切换回hello进程继续执行。 hello进程结束之后，shell将对hello进程执行回收操作，如果shell（bash）在hello进程结束之前已终止，则hello进程成为一个僵尸进程，不久之后将由操作系统的pid为1的进程——init进程负责回收。 1.2 环境与工具 硬件环境： Intel(R) Core(TM) i7-6700HQ CPU 8GB RAM Nvidia GTX 1060 128GB SSD 软件环境： Windows 10 Professional x64 Ubuntu 18.04.1 Manjaro 工具： edb gdb cgdb codeblocks vscode vmware 1.3 中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 1.4 本章小结 每一个程序——即使是最简单的hello，都涉及了精巧的设计和复杂的操作，从硬件到软件的全方位配合，才使得现今计算机如此高效。这些复杂精巧的设计和机制值得每一位CS学生去学习。从底层出发，才能更好地进行顶层的设计。接下来，我们就要对hello从编译到执行再到被回收的每一步进行深入的了解。 "},"chapter2.html":{"url":"chapter2.html","title":"第二章 预处理","keywords":"","body":"第二章 预处理 2.1 预处理的概念与作用 预处理是指在编译之前的预处理阶段，预处理程序对程序进行的操作，通常会生成一个.i后缀的预处理文件。 预处理的具体操作来自程序代码中的预编译命令。预处理命令主要有三个方面的内容：1. 宏定义 2. 文件包含 3. 条件编译，这些预处理命令在代码中以符号“#”开头。 预处理的主要作用仅仅是对程序代码文本进行替换操作，如将以#include格式包含的文件内容复制到编译的源文件中，用实际值替换#define定义的宏，以及根据#if的条件决定需要编译的代码。预处理过后程序代码中的预处理指令会被删除。所以预处理器的输出是原程序的一个编辑后的、不包含指令的版本。 2.2 在Ubuntu下的预处理命令 预处理命令如下： gcc -E -o hello.i hello.c 执行效果： 2.3 Hello的预处理结果解析 hello.i内容如下： # 1 \"hello.c\" # 1 \"\" # 1 \"\" # 31 \"\" # 1 \"/usr/include/stdc-predef.h\" 1 3 4 # 32 \"\" 2 # 1 \"hello.c\" ……（8～3099行） int sleepsecs=2.5; int main(int argc,char *argv[]) { int i; if(argc!=3) { printf(\"Usage: Hello 学号 姓名！\\n\"); exit(1); } for(i=0;i其中，由于hello源文件中有三条预处理命令：#include 、#include 、#include ，预处理程序将三个文件中的内容拷贝到预处理文件中，即为以上1～3099行的内容，3100行到最后则是直接复制源文件的内容。如果遇到头文件中包含预处理命令，则递归地将内容复制进去，直到预处理文件中不包含任何预处理命令为止。 预处理文件中除了有正常的其余头文件内容外，还有一些类似下面的内容： # 1 \"/usr/include/stdc-predef.h\" 1 3 4 这些内容都有一个固定的格式： #linenum filename flag 表示一下内容是从这个文件的第开始的，flag有一下几种情况： 开始一个新文件 回到文件（递归返回） 说明以下的内容是来自系统头文件 extern \"C\"。 如以上的例子表示：下面的内容是stdio.h文件第1行起的内容，以下内容是一个新文件(即stdio.h)的内容，系统头文件，extern C。 2.4 本章小结 预处理是整个编译过程的第一步，事实上没有任何计算的过程的，仅仅是将一些用到的、涉及到的函数库头文件复制到程序源文件中、在程序代码中替换宏定义，并根据条件编译的条件保留相应的内容。该举措仅仅是为了简化之后的动作。有时，预处理动作也被包含在编译中。 "},"chapter3.html":{"url":"chapter3.html","title":"第三章 编译","keywords":"","body":"第三章 汇编 3.1 编译的概念与作用 编译，是指把ascii码形式的高级程序设计程序书写的源程序文件，翻译成等价的ascii码形式的汇编语言格式的文件。通常，源程序文件是一个经过预处理过后的.i文件。 编译除了基本的翻译操作，还包含语法检查和目标程序优化等功能。在翻译地过程中动态地检查语法错误，并将错误实时地反映出错误的类型和部位等有关信息。目标程序优化分为表达式优化、循环优化或程序全局优化，用以提高目标程序的质量,即占用的存储空间少,程序的运行时间短。 编译也仅仅是在文本方面的操作，并没有生成任何可执行的二进制代码。在编译过后，程序更加接近底层，方便进行下一步汇编的操作。 3.2 在Ubuntu下编译的命令 编译命令： gcc -S -o hello.s hello.i 执行效果截图： 3.3 Hello的编译结果解析 3.3.1 常量 hello.c程序代码中出现了两种常量：字符串常量和数字常量，其中两个字符串常量：分别是\"Usage: Hello 学号 姓名！\\n\"和\"Hello %s %s\\n\"，这两个常量分别标记为.LC0和.LC1标签。调用时使用相对寻址，$rip加上标签的值即可找到对应的字符串。 .LC0: .string \"Usage: Hello \\345\\255\\246\\345\\217\\267 \\345\\247\\223\\345\\220\\215\\357\\274\\201\" .LC1: .string \"Hello %s %s\\n\" 四个数字常量分别是3、1、0、10和0，在汇编语句中以立即数的形式存储。如下： cmpl $3, -20(%rbp) movl $1, %edi movl $0, -4(%rbp) cmpl $9, -4(%rbp) movl $0, %eax 其中，常量10作为循环结束条件的一部分，小于10被编译器修改成了小于等于9。 3.3.2 变量 程序中出现了两个变量：分别是全局变量sleepsecs和局部变量i。 全局变量sleepsecs的声明在标签sleepsecs中，调用时用$rip加上标签的值即可找到该变量。以下语句表明sleepsecs是一个长度为两个字节的长整型数据（实际上相当于short）。 sleepsecs: .long 2 局部变量i没有特殊声明，使用时仅仅是使用-4(%rbp)这个栈上的空间来保存一下i的内容。如下： movl $0, -4(%rbp) addl $1, -4(%rbp) cmpl $9, -4(%rbp) 3.3.3 表达式 程序中共出现五个表达式：两个布尔表达式和三个算数表达式。 布尔表达式argc!=3是if的条件，在该表达式为真的情况下流程进入if的方法体中，即在argc不等于3时执行if方法体。编译器对它进行了修改，变成了argc等于3时执行跳转，否则顺序执行。如下： cmpl $3, -20(%rbp) je .L2 布尔表达式i sleepsecs: .long 2 运算式i=0是for循环的初始条件，表明执行循环之前先将i赋为0，实际的操作仅是将立即数0移到一个内存中。如下： movl $0, -4(%rbp) 运算式i++是for循环的末尾循环体，在每次循环结束的时候执行。“++”是一个单目运算符，表示i自增1。如下： addl $1, -4(%rbp) 3.3.4 类型转换 hello中出现过一次隐式类型转换。在给sleepsecs赋初值的时候，由于sleepsecs是整型数据，而2.5是浮点型数据，导致精度损失，向下取整，sleepsecs的初值变为2。编译器直接将sleepsecs的值赋为2。如下： sleepsecs: .long 2 3.3.5 控制转移 程序中出现两处控制转移，分别是if语句和for循环语句。 if语句原本条件是argc!=3，条件成立则执行条件内容。编译器将其修改为“如果argc==3则跳转”，循环体内容位于cmpl和je语句下方，而原本的if语句之外的内容则位于.L2标签内，je语句跳转至.L2标签。如下： cmpl $3, -20(%rbp) je .L2 for循环语句由四个部分组成：单次表达式位于.L2，中间循环体和末尾表达式位于.L4，条件表达式位于.L3。首先流程进入.L2执行单次表达式操作，接着jmp到.L3，进行条件表达式的判断，如果不成立（i .L2: movl $0, -4(%rbp) jmp .L3 .L4: movq -32(%rbp), %rax addq $16, %rax movq (%rax), %rdx movq -32(%rbp), %rax addq $8, %rax movq (%rax), %rax movq %rax, %rsi leaq .LC1(%rip), %rdi movl $0, %eax call printf@PLT movl sleepsecs(%rip), %eax movl %eax, %edi call sleep@PLT addl $1, -4(%rbp) .L3: cmpl $9, -4(%rbp) jle .L4 3.3.6 参数传递 程序只涉及main函数两个命令行参数的接收，分别是整型的argc和字符数组指针argv。argc表示参数的个数，而argc则存储着实际的命令行参数。在.main中，首先分配了一个32字节的栈空间，并分别将%edi传入-20(%rbp)、%rsi传入-32(%rbp)处。%edi和%rsi就分别是这两个参数argc和argv。如下： subq $32, %rsp movl %edi, -20(%rbp) movq %rsi, -32(%rbp) 3.3.7 函数调用 hello程序共调用四个函数：printf()，exit()，sleep()和getchar()，其中printf()函数调用两次。而在汇编代码中，如果printf只有一个参数（字符串），则编译器只会调用PUTS函数。在调用之前，都会先将参数mov（lea）到存储参数的寄存器中（通常是%edi或%rdi），再call那个函数。如下： leaq .LC0(%rip), %rdi call puts@PLT movl $1, %edi call exit@PLT leaq .LC1(%rip), %rdi movl $0, %eax call printf@PLT movl sleepsecs(%rip), %eax movl %eax, %edi call sleep@PLT call getchar@PLT 3.3.8 函数返回 hello程序中只有main函数的返回。由于返回值是0，所以将0mov进%eax中，接着执行leave，将栈帧收回（leave等价于movl %ebp %esp，popl %ebp），接着执行ret将栈顶的返回地址弹出到%eip，然后按照%eip的指令地址继续执行，即从hello中退出。如下： movl $0, %eax leave .cfi_def_cfa 7, 8 ret .cfi_endproc 3.4 本章小结 编译几乎是整个过程（从文本到可执行）中最重要的一步了。程序从高级语言的程序变成了较为底层的汇编语言程序，从机器的角度描述了这个程序的行为。编译器对于程序的优化是巨大的，从设备的角度去优化程序，大大减小程序运行的时间，使我们的程序变得设备友好。 "},"chapter4.html":{"url":"chapter4.html","title":"第四章 汇编","keywords":"","body":"第四章 汇编 4.1 汇编的概念与作用 汇编，是将由ascii码存储的汇编文件，转化为二进制形式的可重定位目标文件的过程。通常，源文件是一个经过编译的.s文件。 按照平台的不同，CPU的指令集不同，生成的可重定位目标文件的内容也不同。汇编器根据各个平台的指令集逐条语句翻译为二进制的形式存储。同时将一些常量和全局变量插在目标文件的不同的节里。同时，汇编器还会将ELF文件的信息、机器类型等数据写入ELF头，方便后续操作。 4.2 在Ubuntu下汇编的命令 汇编命令： gcc -c -o hello.o hello.s 执行效果截图（由于hello.o是二进制形式存储，输出不可读）： 4.3 可重定位目标elf格式 hello.o的ELF文件（也是通用的）由三个部分组成： ELF头 ELF头中包含有整个ELF文件的基本信息，包括Magic Number（魔数） 版本、平台、程序入口以及各个部分（ELF头、程序头、节头）的大小。 程序头 告诉系统如何创建进程映像。用来构造进程映像的目标文件必须具有程序头部表，而可重定位目标文件则没有这个头。故显示“本文件中没有程序头。”。 节头 包含了描述文件节区的信息，每个节区在表中都有一项，每一项给出诸如节区名称、节区大小这类信息。可重定位目标文件必须包含节区头部表。 使用readelf -t hello.o即可显示各个节的详细信息，如下： 节头： [号] 名称 类型 地址 偏移量 大小 全体大小 旗标 链接 信息 对齐 [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000081 0000000000000000 AX 0 0 1 [ 2] .rela.text RELA 0000000000000000 00000340 00000000000000c0 0000000000000018 I 10 1 8 [ 3] .data PROGBITS 0000000000000000 000000c4 0000000000000004 0000000000000000 WA 0 0 4 [ 4] .bss NOBITS 0000000000000000 000000c8 0000000000000000 0000000000000000 WA 0 0 1 [ 5] .rodata PROGBITS 0000000000000000 000000c8 000000000000002b 0000000000000000 A 0 0 1 [ 6] .comment PROGBITS 0000000000000000 000000f3 000000000000002b 0000000000000001 MS 0 0 1 [ 7] .note.GNU-stack PROGBITS 0000000000000000 0000011e 0000000000000000 0000000000000000 0 0 1 [ 8] .eh_frame PROGBITS 0000000000000000 00000120 0000000000000038 0000000000000000 A 0 0 8 [ 9] .rela.eh_frame RELA 0000000000000000 00000400 0000000000000018 0000000000000018 I 10 8 8 [10] .symtab SYMTAB 0000000000000000 00000158 0000000000000198 0000000000000018 11 9 8 [11] .strtab STRTAB 0000000000000000 000002f0 000000000000004d 0000000000000000 0 0 1 [12] .shstrtab STRTAB 0000000000000000 00000418 0000000000000061 0000000000000000 0 0 1 重定位节.rela.text的信息如下： 重定位节 '.rela.text' at offset 0x340 contains 8 entries: 偏移量 信息 类型 符号值 符号名称 + 加数 000000000018 000500000002 R_X86_64_PC32 0000000000000000 .rodata - 4 00000000001d 000c00000004 R_X86_64_PLT32 0000000000000000 puts - 4 000000000027 000d00000004 R_X86_64_PLT32 0000000000000000 exit - 4 000000000050 000500000002 R_X86_64_PC32 0000000000000000 .rodata + 1a 00000000005a 000e00000004 R_X86_64_PLT32 0000000000000000 printf - 4 000000000060 000900000002 R_X86_64_PC32 0000000000000000 sleepsecs - 4 000000000067 000f00000004 R_X86_64_PLT32 0000000000000000 sleep - 4 000000000076 001000000004 R_X86_64_PLT32 0000000000000000 getchar – 4 重定位节 '.rela.eh_frame' at offset 0x400 contains 1 entry: 偏移量 信息 类型 符号值 符号名称 + 加数 000000000020 000200000002 R_X86_64_PC32 0000000000000000 .text + 0 .rela.text是.text节的重定位信息。其中，偏移量标识了重定位入口的偏移；信息字段表示重定位入口的类型和符号，其中低8位表示重定位入口的类型， 高24位表示重定位入口的符号在符号表中的下标；类型有两个宏定义，R_X86_64_32表示绝对地址修正（S+A），R_X86_64_PC32表示相对地址修正（S+A-P）。A为保存在被修正位置的值(例如printf重定位处的值是0x00 00 00 00)，P为被修正的位置(相对于段开始的偏移量或者虚拟地址)，S为符号的实际地址，即由信息字段的高24位指定的符号的实际地址。 4.4 hello.o的结果解析 hello.o的反汇编是对hello.o的代码节（.text）的反汇编。其中，汇编器给main函数分配了虚拟地址0000000000000000。每一条语句前都有其对应的机器语言，且每一条语句都有自己相对于main函数的偏移量，跳转时即可通过这个偏移量快速跳转到对应代码处。机器语言由操作符和操作数构成，x86-64的操作符是两个16进制数，由操作数和操作符构成的指令码可以根据平台翻译为汇编语句。 在调用函数处，仅仅是call了一个相对偏移量，方便之后的链接器根据这个偏移量和重定位节将代码链接在一起，使用objdump -d -r hello.o得到的反汇编代码已经在每一个可重定位处结合重定位节将函数标示了出来。同样，在两个字符串常量和sleepsecs全局变量处，仅仅是标示着0x0(%rip)，在链接之后字符串处将指向.rodata区的某个地址，sleepsecs将指向.data区。 由于仅仅是.text节的反汇编，和hello.s不同的是，内容中没有了一些全局变量的声明和初始化，也没有了常量的声明。而且，hello.s在流程控制语句中进行跳转的时候，都是借助标签跳转，如jmp .L3。而在反汇编中的跳转则是直接借助相对于main函数的地址偏移量，如jmp 6f，则直接跳转到相对于main函数的地址偏移0x6f的指令处。 4.5 本章小结 从汇编开始，程序开始变成二进制的形式，虽然不再用户友好，但是愈发地计算机友好。汇编后的程序开始将各个内容（代码，变量等）分节存储，向内存映像上靠拢。存储的重定位节为下一章的链接提供了指引。 "},"chapter5.html":{"url":"chapter5.html","title":"第五章 链接","keywords":"","body":""},"chapter6.html":{"url":"chapter6.html","title":"第六章 HELLO进程管理","keywords":"","body":"第六章 hello进程管理 6.1 进程的概念与作用 进程，是计算机中的程序关于某数据集合上的一次运行活动，是程序（指令和数据）的真正的运行实例，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在当代面向线程设计的计算机结构中，进程是一组相关线程的容器。 进程给每个应用提供了两个抽象：逻辑控制流和私有地址空间。逻辑控制流通过上下文切换让分时处理各个进程，私有地址空间则是通过虚拟内存机制让每个程序仿佛在独占物理内存空间。这样的抽象保证了在不同的情况下运行同样的程序可以得到相同的结果，使得具体的应用不需要关心关心处理器和内存的相关事宜。 6.2 简述壳Shell-bash的作用与处理流程 shell，俗称“壳”（区别于操作系统的内“核”），本质上是一个C语言编写的程序，是用户与linux/unix交互的桥梁，是一个为用户提供操作界面的软件。Linux的shell是一个可以解析用户指令并执行相应操作的C程序。Linux的shell使用较多的有sh、bash和zsh。 Linux下的shell执行的简易流程： 读取输入的命令。 分割命令为各个单词，各个单词成为token。 检查第一个token是否是shell的内置命令，如果是则直接调用运行。 如果不是内置命令，则按照第一个token的路径查找可执行文件，并将其它token作为参数运行。 如果最后一个token不是“&”，则该条命令在前台运行，shell将会阻塞等待程序终止或停止，并输出程序的输出。如果最后一个是“&”，则执行后shell将不会阻塞，直接进入等待下一条命令输入的状态。 6.3 hello的fork进程创建过程 在收到执行hello的命令后，shell调用fork函数创建了一个新的进程。调用fork函数的shell进程就是父进程，产生的新进程称为子进程。并且fork函数从两个进程中分别返回，父进程中返回的是子进程的进程id，子进程中返回的是0。接着两个进程互不干扰地继续执行。 在早期的Linux系统中，fork一个进程是将该进程的所有内存复制产生一个新的内存映像。由于这种方式比较浪费内存，在现在的操作系统中，fork刚执行后并不会直接复制父进程的所有内存，子进程的代码段、数据段、堆栈都暂时指向父进程的页表，即两个的虚拟空间不同，但是物理空间是同一个。当父进程或子进程有修改段段行为发生时，再为子进程的段分配空间，直到子进程执行exec函数之前，代码段都是和父进程共享的。执行exec函数后，子进程和父进程就拥有了完全分离的两个物理空间，子进程独立地执行新的代码段。这种技术被称为写时复制技术。 6.4 hello的execve过程 被fork出的子进程执行execve函数，进程陷入内核模式，用以访问hello的可执行目标文件。进程先执行一些必要的安全检查，读取hello开头的128个字节的ELF头（X86架构的Linux）以获取该程序的基本信息，接着将可执行文件映射到当前进程的进程空间中，并覆盖掉原来的进程数据，由于之前与当前进程的父进程共享代码段，此时就会在物理内存中为代码段分配空间。进程将EIP段值设置为新的可执行程序的入口地址，如果可执行程序是静态链接的程序，或不需要其他的动态链接库，则新的入口地址就是新的可执行文件的main函数地址；如果可执行程序还需要其他的动态链接库，则入口地址是链接器ld的入口地址。最后返回用户模式，CPU从新的EIP的地址中取指执行，即hello开始执行。至此，老进程的上下文已经完全被新的进程替代，但依然保有原来的进程ID。 6.5 hello的进程执行 进程时间片是为了进行进程调度而产生的概念。每个进程被分配给一个时间段，成为其时间片，也就是该进程允许运行的时间，如果在属于该进程的时间片结束时该进程依然在运行，则CPU将被剥夺并分配给另一个进程，如果进程在时间片结束前阻塞或结束，则CPU立刻进行切换。而进程调度所需要做的，仅仅是维护一个进程时间片队列，当一个进程用完其时间片后，它的时间片将被移到队列尾。当hello开始执行一段时间后，其时间片结束，CPU将切换到另一个进程运行。为了在切换回该进程时能够接着上次运行的地方继续运行，内核需要保存进程的一些寄存器的值、堆栈等，这些组成了进程的进程上下文。进程的切换实质上是进程上下文的切换。就这样hello与其它进程交替执行，交替占用CPU，直到hello进程结束。 一般来说，一个进程可以在两种状态下执行，用户模式（用户态）和内核模式（内核态），内核模式的权限高于用户模式的权限。进程每次调用一个系统调用时，进程的运行方式都发生变化：从用户模式切换到内核模式，然后继续执行。当出现系统调用或者发生异常（异常处理程序）时，进程就会从用户态切换回内核态。如果一个进程进入内核模式，那么那个进程就不会被进程调度切换，而会一直占有CPU，直到该进程终止或退出内核模式准备进入用户模式。 进程hello可能会由于用户按下ctrl+z或者ctrl+c向进程发送信号进入内核模式，或者出现缺页异常而进入内核模式，启动异常处理程序，如果是ctrl+z引发异常，异常处理程序将挂起（停止）hello进程，接着进行进程调度切换至其它进程。如果是ctrl+c，异常处理程序将直接终止进程。如果产生缺页异常，异常处理程序将进行系统调用，在磁盘（固态硬盘）上读取相应的虚拟页，并将其装入内存，在从内核模式退出时，将进行系统进程调度，切换到其它进程，当再次切换回hello时，将从上次导致缺页异常的地方再次执行，这次则不会引发缺页异常，进程正常地执行下去。 6.6 hello的异常与信号处理 在hello执行的时候按下ctrl+c，截图如下： 按下ctrl+c后，使用ps命令可以看出，hello进程已完全终止。 当用户按下ctrl+c后，shell进程通过内核向hello进程发送SIGINT信号，hello进程捕获到了这个信号后，陷入内核模式，由于没有指定信号处理程序，进程将启动默认的处理程序，处理程序执行默认动作，终止hello进程。 在hello执行的时候按下ctrl+z，截图如下： 显示出进程hello已经被停止，进程id为28805。当用户按下ctrl+z后，内核向进程发送SIGTSTP信号，该信号的默认动作是将当前运行在前台的进程挂起（停止）。 此时使用命令ps -a | grep hello，显示如下： 显示出进程id，hello进程名标红表示该进程已停止。 输入命令jobs -l，其中-l表示显示作业的进程id，显示如下： 该命令表示显示后台的所有工作，可以看到当前后台仅有一个工作hello，且suspended表示停止（挂起）状态。“+”表示这是最近一个放入后台的工作。 pstree命令可以以树状图的形式显示进程间的关系，由于进程树过大，只能截取部分： 可以看到，hello进程的从属关系为： system => system => gnome-terminal => zsh => hello 其中，system是所有进程的祖先进程。 使用fg命令加上作业id，可以将该进程转为前台进程并继续执行，输入fg %1，如下： 作业继续执行（continued）。 在进程挂起（suspended）时，使用kill命令，给进程发送信号9，可终止目标进程，如下： 显示进程已被终止（killed），再使用ps命令时则查看不到该进程，说明该进程确实以终止。kill -9 \\命令向进程发送信号9，即SIGKILL，该信号的默认处理动作是直接终止进程。 hello进程执行时还可能引发缺页异常，该异常是由虚拟地址所在的虚拟页映射的物理页没有在内存中分配导致的。当发生这个异常时，进程将陷入内核模式，启动缺页异常的对应处理程序。内核将找到引发异常的虚拟页，并将其写入物理内存中，并退出处理程序。进程将再次执行上次发生缺页异常的代码。 ​ 异常与信号处理： 当进程发生异常时，会陷入内核模式，如果没有事先设定好处理程序的话，执行对应的默认异常处理程序，进行默认处理动作，从处理程序返回后，进程有可能接着运行，也有可能重新运行导致异常产生的代码，也有可能终止或挂起。由于信号属于中断，是一种异常，所以处理的过程相似。 6.7 本章小结 进程的概念是当代计算机最重要的概念之一，它使多任务同时运行成为可能。每一个进程都如同独占CPU和内存一般，保证了运行的连贯性和结果一致性。异常和信号机制使我们可以灵活地调度协调各个各个进程。 "},"chapter7.html":{"url":"chapter7.html","title":"第七章 HELLO存储管理","keywords":"","body":"第七章 hello的存储管理 7.1 hello的存储器地址空间 逻辑地址，是指由程序产生的和段相关的偏移地址，这个地址是相对于进程数据段的地址，与物理内存和物理地址无关。汇编语言中出现的地址操作中的地址就是逻辑地址，表示地址所代表的位置相对于段开头的偏移。一个逻辑地址由一个段标识符加上一个指定段内相对地址的偏移量组成，表示为 [段标识符：段内偏移量]。通常，在汇编语言中，段内偏移量部分恰好和该地址对应的虚拟地址相同。逻辑地址反映的是硬件平台段式管理的结果，是硬件平台段式管理转换前的地址。 举hello的反汇编代码中的一条操作为例： mov 0x200842(%rip),%eax 该条操作有一个相对寻址，寻到的地址为寄存器%rip中的地址加上0x200842的结果，这个结果就是其逻辑地址的段内偏移量。 线性地址，与逻辑地址的概念类似，都是一个虚拟的、不真实的地址（与物理地址的概念相对）。逻辑地址是对应的硬件平台段式管理转换前的地址，那么线性地址则对应了硬件页式内存的转换前的地址。线性地址是逻辑地址的段偏移地址加上该段的基地址（段标识符表示的段的开头地址）得到的。线性地址又被称为虚拟地址。 物理地址，就是数据真实地在物理内存中存储的地址，只有在程序运行时才会分配，同一个进程多次运行，物理地址空间都可能不同，由操作系统调度决定。 7.2 Intel逻辑地址到线性地址的变换-段式管理 汇编语言中出现的地址，都是逻辑地址（为了向下兼容），需要转换成线性地址，再经过MMU转换成物理地址才可以访问。 如上面那个例子： mov 0x200842(%rip),%eax 设x为0x200842加上%rip中的地址值。那么x就是一个逻辑地址的段偏移量，代表着数据的段偏移量，我们需要找到该段的基地址，相加即可得到线性地址。在x86保护模式下，段的信息（段基地址、长度、权限等）即段描述符占8个字节，段信息无法直接存放在段寄存器中（段寄存器只有2字节）。Intel的设计是段描述符集中存放在GDT（全局段描述符表）或LDT（局部段描述符表）中。逻辑地址是由段标识符和段内偏移量组成，其中段内标识符是一个16位长的字段，前13位表示段索引号，后3位是一些硬件信息。硬件信息中有一位TI，决定了对应的段描述符是在GDT还是在LDT中。根据TI和段索引号，操作系统在对应的段描述符表中即可找到对应的段描述符，取出段的基地址，与段偏移量相加即得到对应的线性地址。如下图： 在Linux中，逻辑地址等于线性地址，Linux所有的段（用户代码段、用户数据段、内核代码段、内核数据段）的线性地址都是从0x00000000 开始。Linux通过这种方式运行在分段的x86上，却绕开了分段管理，进行分页的内存管理。 7.3 Hello的线性地址到物理地址的变换-页式管理 CPU通过MMU（内存管理单元）将线性地址转换为物理地址，即可通过物理地址向物理内存取出数据。 分页是CPU提供的内存管理的机制，Linux利用这种机制实现了内存管理。控制寄存器CR0的最高位PG位决定着分页机制是否有效，如果PG为1，则分页机制有效，需要经过页表查找来将线性地址转换为物理地址，如果PG为0，分页机制无效，线性地址可直接作为物理地址使用。 分页的基本原理是将内存划分为若干相同大小的单元，每个单元称为一页，每一页包含4K字节的地址空间。为了转换为物理地址，CPU需要一个线性地址转换为物理地址的查找表，即页表。为了简化处理，使用二级页表。在这种分页管理机制当中，第一级页表被称为页目录表，用于存放每个页表的基地址，第二级页表才存储着各个页的基地址。由于每一个进程都有独立的虚拟内存，那么每一个进程都有一个与之对应的页目录表，这个页目录表的基地址存储在CPU的寄存器CR3中，在进行进程调度的时候，由操作系统负责将该寄存器的值修改为当前进程的页目录表的基地址。 在x86架构中，每一条线性地址是32位，分成三部分：前10位是页目录索引，中间10位是页表索引，最后12位是偏移量。 当CPU获得一个线性地址时，它会从CR3中取得进程的页目录地址，取出其前20位，得到进程的页目录基地址。根据取出来的页目录的基地址以及线性地址的前十位，进行组合得到线性地址的前十位的索引对应的项在页目录中地址，根据该地址可以取到该地址上的值，该值就是二级页表项的基址。根据二级页表项的基地址，结合线性地址的中间10位页表索引，可以获得线性地址对应的物理页在内存中的地址在二级页表中的地址。根据这个地址即可获得物理页在内存中的基地址，在根据线性地址的最后12位偏移量得到具体的物理地址。 7.4 TLB与四级页表支持下的VA到PA的变换 TLB，即翻译后备缓冲器，是一个MMU中关于页表项（PTE）的小的缓存，这是一个组相连缓存。当存在TLB时，虚拟地址的虚拟页号（VPN）被分割称为两个部分：TLB标记（TLBT）和TLB索引（TLBI）。在CPU取得一个虚拟地址时， MMU对进行翻译。MMU根据TLBI获得TLB中对应的组，并查找组内是否有标记和TLBT相同的行，如果存在，则TLB命中，MMU从中取出PTE，获取物理页在内存中的基地址，加上虚拟地址的最后12位偏移（VPO）得到具体的物理地址。如果TLB未命中（PTE不在TLB中），MMU将逐级查找PTE。四级页表下，只有第一级页表（页目录表）将常驻主存，其他三级页表将在需要时装入主存。四级页表下，虚拟地址中的VPN被划分成四个部分，分别对应着不同级别的页表的偏移量。CPU首先从CR3中取出第一级页表（页目录表）的基地址，以VPN1为偏移量在第一级页表中即可查找出第二级页表的基地址。如此一级一级查找，最后以VPN4为偏移量从第四级页表中取得PTE，将该PTE返回给CPU，MMU将该PTE存入TLB中（必要时驱逐）后，从PTE解析出物理页的基地址，加上虚拟地址的偏移量（VPO）得到最后的物理地址。 7.5 三级Cache支持下的物理内存访问 CPU的三级Cache都是组相连高速缓存，上一级是下一级的缓存，第三级是内存的缓存。每一级缓存是由多个组组成，一个组内有多个行，一个行由有效位（指示该行是否有效）、标记位（行的唯一标记）和高速缓存块（数据）组成。 当CPU获得一个物理地址时，将该物理地址分为三个部分：标记、组索引和块偏移，CPU按照组索引在第一级Cache查找到相应的组，遍历组内的行查找是否有标记和地址的标记相同且有效的行，如果存在则一级缓存命中，按照块偏移量从该行的高速缓存块中取出数据块。如果一级缓存不命中，则回去二级缓存中查找是否有标记和地址的标记相同且有效的行，如果存在则二级缓存命中，将该缓存行写回一级缓存中（必要时驱逐），并从一级缓存中的行中的高速缓存块中取得数据块。如果二级缓存不命中，三级缓存查找同理。如果三级缓存命中，则将缓存行逐级写回二级缓存和一级缓存（必要时驱逐），最后一级缓存中取数据块（所有的情况都是从一级缓存中取数据块）。如果三级缓存不命中，则会从内存中按照地址查找到数据，获取出一整个行大小的数据，构建成缓存行写入三级缓存，并逐级写回，最后从一级缓存中取出数据块。 7.6 hello进程fork时的内存映射 内存映射，是指一个虚拟内存空间和一个磁盘上的对象之间的映射关系。内存映射分为两种：文件映射和匿名映射，文件映射将一个普通文件的全部或者一部分映射到进程的虚拟内存中，映射后，进程就可以直接在对应的内存区域操作文件内容；匿名映射没有对应的文件或者对应的文件时虚拟文件，映射后会把内存分页全部初始化为0。如果多个进程都会同一个内存区域操作时，会根据映射的特性，会有不同的行为。 内核调用fork函数时主要涉及的内存映射主要是虚拟地址空间到物理地址空间的映射。当多个进程映射了同一个内存区域时，它们会共享物理内存的相同分页。根据映射特征可分为私有映射和共享映射：私有映射的映射的内容对其他进程不可见，而共享映射中某一个进程对共享的内存区域操作都对其他进程可见。 当一个进程调用fork函数创建新的子进程时，内核在虚拟内存上分配一个空间，并且完全复制父进程的映射，即子进程和父进程的虚拟地址空间都映射到了同一个物理地址空间。然而，两个进程的每个区域结构都标记为私有的。这样，在父进程或者子进程在对内存数据进行修改时，会涉及一个技术：写时复制技术（copy-on-write）。当子进程或者父进程对页进行修改时，子进程就会在物理内存上创建新的页，并映射虚拟内存上的对应页到新的物理页，这样就可以保证子进程和父进程的地址空间私有。 7.7 hello进程execve时的内存映射 当一个进程调用execve函数后（刚调用fork），由于需要放弃继承自父进程的物理地址空间，使用独有的物理地址空间，内核将这部分与父进程共享的物理内存对应的虚拟内存取消映射，并将该部分虚拟内存释放掉。 接着内核读取hello的ELF头，按照节头信息将各个节装入虚拟内存中（需要时分配空间）。在物理内存中分配一个区域，将虚拟内存中进程的代码段和数据段映射到新分配的区域（真正的将代码和数据装入物理内存是在缺页时），并将映射标记为私有映射。 7.8 缺页故障与缺页中断处理 缺页故障，即缺页中断，出现的原因是虚拟地址空间的页不必常驻物理内存。在执行一条指令时，如果内核发现要访问的页不在物理内存中（有效位为0），则停止该命令的执行，产生一个物理页不存在的异常，即缺页异常。缺页异常的处理程序可以通过从虚拟内存（磁盘上）中装载虚拟页到物理内存中的方式解决异常，处理程序返回后，进程将再次执行引发异常的指令，此次由于页已经位于物理内存中，指令将顺利执行，不发生异常。 造成缺页中断可能有以下几种情况： MMU未创建虚拟页和物理页的映射关系，且该虚拟地址不在当前进程的线性区（虚拟地址空间）； MMU未创建虚拟页和物理页的映射关系，但该虚拟地址在当前进程的线性区； 请求读或写与该页的读写保护权限不一致； 使用malloc或mmap后，内核没有给虚拟页创建物理页，读写该页都会发生缺页异常； 使用fork创建新进程时，父子进程的虚拟页都映射到同一个物理页，且物理页为只读，当父子进程都页进行写操作时，会造成缺页异常（类似情况3）； 被访问的页是脏页（物理页面已被修改但没有写回虚拟页面）会造成缺页异常。 造成缺页中断后，内核陷入内核模式，调用异常处理程序，异常处理程序对上述情况进行排查处理。 若出现情况1，可以肯定是一个编码错误，内核将向进程发送一个SIGKILL信号，强行终止该进程。情况2可能是由栈溢出导致的缺页中断，内核向进程发送一个SIGSEGV信号，进程收到该信号后按照段错误（segment fault）进行处理。情况3读写权限不一致，内核向进程发送一个SIGKILL信号（因为访问了一个被保护的区域），强行终止进程。情况4说明地址有效且没有保护权限问题，系统将检查物理内存中是否有空闲的页，如果有空闲页，就会执行系统调用，将虚拟内存上的页写入物理内存，此时内核将暂时挂起该进程，调度其它进程直到写入操作完成，操作完成后，调度执行该进程，将EIP指向造成缺页异常的指令并重新执行，此时将正常执行；如果没有空闲页，将按照一定的策略驱逐一个物理页并进程同样的流程。情况5发生在fork之后，当父子进程对页进程写操作时，内核会执行写时复制，将被写的物理页复制一份，并将子进程的虚拟页映射到新的物理页，并再次执行出现异常的语句。情况6访问脏页，则将该页面写回磁盘（虚拟内存），内核挂起造成异常的进程调度到其它进程，直到写回结束，并且将被写回的物理页标记为不可驱逐，避免被其它进程替换。待写回完成后，再次执行造成异常的指令。 7.9动态存储分配管理 在操作系统中，内存管理主要以以下三种方式存在：静态存储区的内存管理、栈上的内存管理、堆上的内存管理。静态存储区大小在进程运行时不会改变，也不会重新分配，栈上的内存由操作系统负责分配和释放，而堆上的内存管理，又称为动态内存管理，程序在运行时通过malloc申请内存，这部分内存存在于堆上，生命周期由程序自己掌控：何时分配和何时释放（free）。 C语言中的malloc和free对动态内存进行分配和释放，这里的分配和释放是基于虚拟内存的，真正的物理内存的分配和释放由操作系统进行调度（缺页）。 malloc进行内存分配时，分不同情况调用两个函数：brk和mmap：当进程所需要分配的内存较大时（大于1M），malloc会使用mmap以页为单位（4K）分配内存；当所需的内存较小时，会使用brk在进程的堆上分配内存，一般来说，从堆分配出来的内存空间，系统一般不会回收，只有当进程的堆大小到达最大限额时或者没有足够连续大小的空间来为进程继续分配所需内存时，才会回收不用的堆内存。malloc使用brk分配内存才属于动态内存分配。 操作系统维护着一个堆上可用内存块的链表，称为空闲链表。当进程调用brk时，将沿着空闲链表找到一个足够大（大于等于所需空间）的内存块，并将其一分为二，一块大小与用户请求的大小相等，另一块大小就是空闲块剩下的字节，然后将分配给进程的那块返回，将剩下的那块链到空闲链表上。 由于多次分配，可能将堆划分为许多小块的空闲内存块，当进程请求一个较大的内存块时，可能空闲链上已经没有足够大的空闲块。这时，malloc请求延时，内核将对堆上的内存进行必要的整理，将相邻的两个较小的空闲块合成较大的空闲块，之后再次进行查找，分割并返回合适的内存块。如果依旧没有足够大的内存块时，内核将对不使用的对内存进行主动回收。 当进程调用free时，将用户释放的内存块标记为空闲，并且将其链到空闲链上，并合并相邻的（前后）空闲块为一整个空闲块。 通常，释放内存会使用两种不同的策略：LIFO（后进先出）法和地址顺序法。LIFO法将新释放的块直接放置在空闲链表的开始处，这样做的好处是较为简单，但是会造成较多的碎片内存。通常，我们使用地址顺序法，按照地址的大小将新的空闲块插入空闲链表，虽然需要遍历，但是可以大大减小碎片内存的产生。 7.10本章小结 进程的顺利运行，需要多方面的配合：CPU、内存、硬盘、操作系统……软硬件间的协调调度保证了进程的执行。缓存机制加速了进程的运行，使CPU几乎不需要和缓慢的存储打交道，用最快的速度取出想要的数据。虚拟内存和CPU分时机制，使进程仿佛独占了所有的资源。虚拟地址和物理地址的分配转换，保证了每个进程结构的一致性。 "},"chapter8.html":{"url":"chapter8.html","title":"第八章 HELLO的IO管理","keywords":"","body":""},"conclusion.html":{"url":"conclusion.html","title":"结论","keywords":"","body":""},"attachment.html":{"url":"attachment.html","title":"附件","keywords":"","body":""},"reference.html":{"url":"reference.html","title":"参考文献","keywords":"","body":""}}