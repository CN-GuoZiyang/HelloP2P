{"./":{"url":"./","title":"摘要","keywords":"","body":"Introduction "},"chapter1.html":{"url":"chapter1.html","title":"第一章 概述","keywords":"","body":"第一章 概述 1.1 Hello简介 hello.c文件以ascii码的形式将C语言代码存在磁盘或固态硬盘上。C预处理器（cpp）首先将hello.c文件翻译成ascii码的预处理文件hello.i。在预处理文件中包含着一些头文件的路径以及宏定义等。接着，C编译器（cc1）将hello.i翻译成ascii存储等汇编语言文件hello.s。然后，汇编器（as）将hello.s翻译成一个二进制形式的可重定位目标文件hello.o，可重定位目标文件hello.o中包含有二进制的代码和数据。最后，链接器程序（ld）将hello.o与其它.o文件（如果有的话）以及系统的目标文件链接起来，生成二进制的可执行目标文件hello。用户通过壳（shell）输入运行hello的命令，shell解析该命令之后，fork出一个子进程，在该子进程中调用execve以运行hello。 内核调用系统函数mmap函数将磁盘（硬盘）文件映射到进程的虚拟内存空间。接着进程开始逐步对这片映射空间进行访问，引发缺页异常，逐步将文件中内容拷贝到主存。CPU将虚拟内存地址发送给内存管理单元（MMU），MMU向主存中常驻的页表请求对应的物理地址，并将该物理地址发送给主存，主存取出数据返回给CPU。转换检测缓冲区（TLB）加速了这一过程。由于数据量较大，页表分为四级，通常只有一级页表常驻主存，剩下的都存在磁盘上。处理器开始逐句逐句取指、译码、执行，并且在多进程的情况下进行分时管理。如果遇到要对磁盘数据进行操作，处理器会首先向最高级缓存请求，如果命中直接返回，如果不命中则向下级缓存请求直到命中为止，接着再逐级写回（必要时驱逐）。如遇到要对磁盘或者输入输出流进行操作，则此时产生了一个异常，操作系统向hello进程发送一个信号，使其暂时挂起，执行异常处理程序，并进入内核模式，执行上下文切换操作切换至其它进程执行，直到对磁盘或者IO的操作结束后，操作系统又切换回hello进程继续执行。 hello进程结束之后，shell将对hello进程执行回收操作，如果shell（bash）在hello进程结束之前已终止，则hello进程成为一个僵尸进程，不久之后将由操作系统的pid为1的进程——init进程负责回收。 1.2 环境与工具 硬件环境： Intel(R) Core(TM) i7-6700HQ CPU 8GB RAM Nvidia GTX 1060 128GB SSD 软件环境： Windows 10 Professional x64 Ubuntu 18.04.1 Manjaro 工具： edb gdb cgdb codeblocks vscode vmware 1.3 中间结果 列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。 1.4 本章小结 每一个程序——即使是最简单的hello，都涉及了精巧的设计和复杂的操作，从硬件到软件的全方位配合，才使得现今计算机如此高效。这些复杂精巧的设计和机制值得每一位CS学生去学习。从底层出发，才能更好地进行顶层的设计。接下来，我们就要对hello从编译到执行再到被回收的每一步进行深入的了解。 "},"chapter2.html":{"url":"chapter2.html","title":"第二章 预处理","keywords":"","body":"第二章 预处理 2.1 预处理的概念与作用 预处理是指在编译之前的预处理阶段，预处理程序对程序进行的操作，通常会生成一个.i后缀的预处理文件。 预处理的具体操作来自程序代码中的预编译命令。预处理命令主要有三个方面的内容：1. 宏定义 2. 文件包含 3. 条件编译，这些预处理命令在代码中以符号“#”开头。 预处理的主要作用仅仅是对程序代码文本进行替换操作，如将以#include格式包含的文件内容复制到编译的源文件中，用实际值替换#define定义的宏，以及根据#if的条件决定需要编译的代码。预处理过后程序代码中的预处理指令会被删除。所以预处理器的输出是原程序的一个编辑后的、不包含指令的版本。 2.2 在Ubuntu下的预处理命令 预处理命令如下： gcc -E -o hello.i hello.c 执行效果： 2.3 Hello的预处理结果解析 hello.i内容如下： # 1 \"hello.c\" # 1 \"\" # 1 \"\" # 31 \"\" # 1 \"/usr/include/stdc-predef.h\" 1 3 4 # 32 \"\" 2 # 1 \"hello.c\" ……（8～3099行） int sleepsecs=2.5; int main(int argc,char *argv[]) { int i; if(argc!=3) { printf(\"Usage: Hello 学号 姓名！\\n\"); exit(1); } for(i=0;i其中，由于hello源文件中有三条预处理命令：#include 、#include 、#include ，预处理程序将三个文件中的内容拷贝到预处理文件中，即为以上1～3099行的内容，3100行到最后则是直接复制源文件的内容。如果遇到头文件中包含预处理命令，则递归地将内容复制进去，直到预处理文件中不包含任何预处理命令为止。 预处理文件中除了有正常的其余头文件内容外，还有一些类似下面的内容： # 1 \"/usr/include/stdc-predef.h\" 1 3 4 这些内容都有一个固定的格式： #linenum filename flag 表示一下内容是从这个文件的第开始的，flag有一下几种情况： 开始一个新文件 回到文件（递归返回） 说明以下的内容是来自系统头文件 extern \"C\"。 如以上的例子表示：下面的内容是stdio.h文件第1行起的内容，以下内容是一个新文件(即stdio.h)的内容，系统头文件，extern C。 2.4 本章小结 预处理是整个编译过程的第一步，事实上没有任何计算的过程的，仅仅是将一些用到的、涉及到的函数库头文件复制到程序源文件中、在程序代码中替换宏定义，并根据条件编译的条件保留相应的内容。该举措仅仅是为了简化之后的动作。有时，预处理动作也被包含在编译中。 "},"chapter3.html":{"url":"chapter3.html","title":"第三章 编译","keywords":"","body":"第三章 汇编 3.1 编译的概念与作用 编译，是指把ascii码形式的高级程序设计程序书写的源程序文件，翻译成等价的ascii码形式的汇编语言格式的文件。通常，源程序文件是一个经过预处理过后的.i文件。 编译除了基本的翻译操作，还包含语法检查和目标程序优化等功能。在翻译地过程中动态地检查语法错误，并将错误实时地反映出错误的类型和部位等有关信息。目标程序优化分为表达式优化、循环优化或程序全局优化，用以提高目标程序的质量,即占用的存储空间少,程序的运行时间短。 编译也仅仅是在文本方面的操作，并没有生成任何可执行的二进制代码。在编译过后，程序更加接近底层，方便进行下一步汇编的操作。 3.2 在Ubuntu下编译的命令 编译命令： gcc -S -o hello.s hello.i 执行效果截图： 3.3 Hello的编译结果解析 3.3.1 常量 hello.c程序代码中出现了两种常量：字符串常量和数字常量，其中两个字符串常量：分别是\"Usage: Hello 学号 姓名！\\n\"和\"Hello %s %s\\n\"，这两个常量分别标记为.LC0和.LC1标签。调用时使用相对寻址，$rip加上标签的值即可找到对应的字符串。 .LC0: .string \"Usage: Hello \\345\\255\\246\\345\\217\\267 \\345\\247\\223\\345\\220\\215\\357\\274\\201\" .LC1: .string \"Hello %s %s\\n\" 四个数字常量分别是3、1、0、10和0，在汇编语句中以立即数的形式存储。如下： cmpl $3, -20(%rbp) movl $1, %edi movl $0, -4(%rbp) cmpl $9, -4(%rbp) movl $0, %eax 其中，常量10作为循环结束条件的一部分，小于10被编译器修改成了小于等于9。 3.3.2 变量 程序中出现了两个变量：分别是全局变量sleepsecs和局部变量i。 全局变量sleepsecs的声明在标签sleepsecs中，调用时用$rip加上标签的值即可找到该变量。以下语句表明sleepsecs是一个长度为两个字节的长整型数据（实际上相当于short）。 sleepsecs: .long 2 局部变量i没有特殊声明，使用时仅仅是使用-4(%rbp)这个栈上的空间来保存一下i的内容。如下： movl $0, -4(%rbp) addl $1, -4(%rbp) cmpl $9, -4(%rbp) 3.3.3 表达式 程序中共出现五个表达式：两个布尔表达式和三个算数表达式。 布尔表达式argc!=3是if的条件，在该表达式为真的情况下流程进入if的方法体中，即在argc不等于3时执行if方法体。编译器对它进行了修改，变成了argc等于3时执行跳转，否则顺序执行。如下： cmpl $3, -20(%rbp) je .L2 布尔表达式i sleepsecs: .long 2 运算式i=0是for循环的初始条件，表明执行循环之前先将i赋为0，实际的操作仅是将立即数0移到一个内存中。如下： movl $0, -4(%rbp) 运算式i++是for循环的末尾循环体，在每次循环结束的时候执行。“++”是一个单目运算符，表示i自增1。如下： addl $1, -4(%rbp) 3.3.4 类型转换 hello中出现过一次隐式类型转换。在给sleepsecs赋初值的时候，由于sleepsecs是整型数据，而2.5是浮点型数据，导致精度损失，向下取整，sleepsecs的初值变为2。编译器直接将sleepsecs的值赋为2。如下： sleepsecs: .long 2 3.3.5 控制转移 程序中出现两处控制转移，分别是if语句和for循环语句。 if语句原本条件是argc!=3，条件成立则执行条件内容。编译器将其修改为“如果argc==3则跳转”，循环体内容位于cmpl和je语句下方，而原本的if语句之外的内容则位于.L2标签内，je语句跳转至.L2标签。如下： cmpl $3, -20(%rbp) je .L2 for循环语句由四个部分组成：单次表达式位于.L2，中间循环体和末尾表达式位于.L4，条件表达式位于.L3。首先流程进入.L2执行单次表达式操作，接着jmp到.L3，进行条件表达式的判断，如果不成立（i .L2: movl $0, -4(%rbp) jmp .L3 .L4: movq -32(%rbp), %rax addq $16, %rax movq (%rax), %rdx movq -32(%rbp), %rax addq $8, %rax movq (%rax), %rax movq %rax, %rsi leaq .LC1(%rip), %rdi movl $0, %eax call printf@PLT movl sleepsecs(%rip), %eax movl %eax, %edi call sleep@PLT addl $1, -4(%rbp) .L3: cmpl $9, -4(%rbp) jle .L4 3.3.6 参数传递 程序只涉及main函数两个命令行参数的接收，分别是整型的argc和字符数组指针argv。argc表示参数的个数，而argc则存储着实际的命令行参数。在.main中，首先分配了一个32字节的栈空间，并分别将%edi传入-20(%rbp)、%rsi传入-32(%rbp)处。%edi和%rsi就分别是这两个参数argc和argv。如下： subq $32, %rsp movl %edi, -20(%rbp) movq %rsi, -32(%rbp) 3.3.7 函数调用 hello程序共调用四个函数：printf()，exit()，sleep()和getchar()，其中printf()函数调用两次。而在汇编代码中，如果printf只有一个参数（字符串），则编译器只会调用PUTS函数。在调用之前，都会先将参数mov（lea）到存储参数的寄存器中（通常是%edi或%rdi），再call那个函数。如下： leaq .LC0(%rip), %rdi call puts@PLT movl $1, %edi call exit@PLT leaq .LC1(%rip), %rdi movl $0, %eax call printf@PLT movl sleepsecs(%rip), %eax movl %eax, %edi call sleep@PLT call getchar@PLT 3.3.8 函数返回 hello程序中只有main函数的返回。由于返回值是0，所以将0mov进%eax中，接着执行leave，将栈帧收回（leave等价于movl %ebp %esp，popl %ebp），接着执行ret将栈顶的返回地址弹出到%eip，然后按照%eip的指令地址继续执行，即从hello中退出。如下： movl $0, %eax leave .cfi_def_cfa 7, 8 ret .cfi_endproc 3.4 本章小结 编译几乎是整个过程（从文本到可执行）中最重要的一步了。程序从高级语言的程序变成了较为底层的汇编语言程序，从机器的角度描述了这个程序的行为。编译器对于程序的优化是巨大的，从设备的角度去优化程序，大大减小程序运行的时间，使我们的程序变得设备友好。 "},"chapter4.html":{"url":"chapter4.html","title":"第四章 汇编","keywords":"","body":"第四章 汇编 4.1 汇编的概念与作用 汇编，是将由ascii码存储的汇编文件，转化为二进制形式的可重定位目标文件的过程。通常，源文件是一个经过编译的.s文件。 按照平台的不同，CPU的指令集不同，生成的可重定位目标文件的内容也不同。汇编器根据各个平台的指令集逐条语句翻译为二进制的形式存储。同时将一些常量和全局变量插在目标文件的不同的节里。同时，汇编器还会将ELF文件的信息、机器类型等数据写入ELF头，方便后续操作。 4.2 在Ubuntu下汇编的命令 汇编命令： gcc -c -o hello.o hello.s 执行效果截图（由于hello.o是二进制形式存储，输出不可读）： 4.3 可重定位目标elf格式 hello.o的ELF文件（也是通用的）由三个部分组成： ELF头 ELF头中包含有整个ELF文件的基本信息，包括Magic Number（魔数） 版本、平台、程序入口以及各个部分（ELF头、程序头、节头）的大小。 程序头 告诉系统如何创建进程映像。用来构造进程映像的目标文件必须具有程序头部表，而可重定位目标文件则没有这个头。故显示“本文件中没有程序头。”。 节头 包含了描述文件节区的信息，每个节区在表中都有一项，每一项给出诸如节区名称、节区大小这类信息。可重定位目标文件必须包含节区头部表。 使用readelf -t hello.o即可显示各个节的详细信息，如下： 节头： [号] 名称 类型 地址 偏移量 大小 全体大小 旗标 链接 信息 对齐 [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000081 0000000000000000 AX 0 0 1 [ 2] .rela.text RELA 0000000000000000 00000340 00000000000000c0 0000000000000018 I 10 1 8 [ 3] .data PROGBITS 0000000000000000 000000c4 0000000000000004 0000000000000000 WA 0 0 4 [ 4] .bss NOBITS 0000000000000000 000000c8 0000000000000000 0000000000000000 WA 0 0 1 [ 5] .rodata PROGBITS 0000000000000000 000000c8 000000000000002b 0000000000000000 A 0 0 1 [ 6] .comment PROGBITS 0000000000000000 000000f3 000000000000002b 0000000000000001 MS 0 0 1 [ 7] .note.GNU-stack PROGBITS 0000000000000000 0000011e 0000000000000000 0000000000000000 0 0 1 [ 8] .eh_frame PROGBITS 0000000000000000 00000120 0000000000000038 0000000000000000 A 0 0 8 [ 9] .rela.eh_frame RELA 0000000000000000 00000400 0000000000000018 0000000000000018 I 10 8 8 [10] .symtab SYMTAB 0000000000000000 00000158 0000000000000198 0000000000000018 11 9 8 [11] .strtab STRTAB 0000000000000000 000002f0 000000000000004d 0000000000000000 0 0 1 [12] .shstrtab STRTAB 0000000000000000 00000418 0000000000000061 0000000000000000 0 0 1 重定位节.rela.text的信息如下： 重定位节 '.rela.text' at offset 0x340 contains 8 entries: 偏移量 信息 类型 符号值 符号名称 + 加数 000000000018 000500000002 R_X86_64_PC32 0000000000000000 .rodata - 4 00000000001d 000c00000004 R_X86_64_PLT32 0000000000000000 puts - 4 000000000027 000d00000004 R_X86_64_PLT32 0000000000000000 exit - 4 000000000050 000500000002 R_X86_64_PC32 0000000000000000 .rodata + 1a 00000000005a 000e00000004 R_X86_64_PLT32 0000000000000000 printf - 4 000000000060 000900000002 R_X86_64_PC32 0000000000000000 sleepsecs - 4 000000000067 000f00000004 R_X86_64_PLT32 0000000000000000 sleep - 4 000000000076 001000000004 R_X86_64_PLT32 0000000000000000 getchar – 4 重定位节 '.rela.eh_frame' at offset 0x400 contains 1 entry: 偏移量 信息 类型 符号值 符号名称 + 加数 000000000020 000200000002 R_X86_64_PC32 0000000000000000 .text + 0 .rela.text是.text节的重定位信息。其中，偏移量标识了重定位入口的偏移；信息字段表示重定位入口的类型和符号，其中低8位表示重定位入口的类型， 高24位表示重定位入口的符号在符号表中的下标；类型有两个宏定义，R_X86_64_32表示绝对地址修正（S+A），R_X86_64_PC32表示相对地址修正（S+A-P）。A为保存在被修正位置的值(例如printf重定位处的值是0x00 00 00 00)，P为被修正的位置(相对于段开始的偏移量或者虚拟地址)，S为符号的实际地址，即由信息字段的高24位指定的符号的实际地址。 4.4 hello.o的结果解析 hello.o的反汇编是对hello.o的代码节（.text）的反汇编。其中，汇编器给main函数分配了虚拟地址0000000000000000。每一条语句前都有其对应的机器语言，且每一条语句都有自己相对于main函数的偏移量，跳转时即可通过这个偏移量快速跳转到对应代码处。机器语言由操作符和操作数构成，x86-64的操作符是两个16进制数，由操作数和操作符构成的指令码可以根据平台翻译为汇编语句。 在调用函数处，仅仅是call了一个相对偏移量，方便之后的链接器根据这个偏移量和重定位节将代码链接在一起，使用objdump -d -r hello.o得到的反汇编代码已经在每一个可重定位处结合重定位节将函数标示了出来。同样，在两个字符串常量和sleepsecs全局变量处，仅仅是标示着0x0(%rip)，在链接之后字符串处将指向.rodata区的某个地址，sleepsecs将指向.data区。 由于仅仅是.text节的反汇编，和hello.s不同的是，内容中没有了一些全局变量的声明和初始化，也没有了常量的声明。而且，hello.s在流程控制语句中进行跳转的时候，都是借助标签跳转，如jmp .L3。而在反汇编中的跳转则是直接借助相对于main函数的地址偏移量，如jmp 6f，则直接跳转到相对于main函数的地址偏移0x6f的指令处。 4.5 本章小结 从汇编开始，程序开始变成二进制的形式，虽然不再用户友好，但是愈发地计算机友好。汇编后的程序开始将各个内容（代码，变量等）分节存储，向内存映像上靠拢。存储的重定位节为下一章的链接提供了指引。 "},"chapter5.html":{"url":"chapter5.html","title":"第五章 链接","keywords":"","body":""},"chapter6.html":{"url":"chapter6.html","title":"第六章 HELLO进程管理","keywords":"","body":"第六章 hello进程管理 6.1 进程的概念与作用 进程，是计算机中的程序关于某数据集合上的一次运行活动，是程序（指令和数据）的真正的运行实例，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在当代面向线程设计的计算机结构中，进程是一组相关线程的容器。 进程给每个应用提供了两个抽象：逻辑控制流和私有地址空间。逻辑控制流通过上下文切换让分时处理各个进程，私有地址空间则是通过虚拟内存机制让每个程序仿佛在独占物理内存空间。这样的抽象保证了在不同的情况下运行同样的程序可以得到相同的结果，使得具体的应用不需要关心关心处理器和内存的相关事宜。 6.2 简述壳Shell-bash的作用与处理流程 shell，俗称“壳”（区别于操作系统的内“核”），本质上是一个C语言编写的程序，是用户与linux/unix交互的桥梁，是一个为用户提供操作界面的软件。Linux的shell是一个可以解析用户指令并执行相应操作的C程序。Linux的shell使用较多的有sh、bash和zsh。 Linux下的shell执行的简易流程： 读取输入的命令。 分割命令为各个单词，各个单词成为token。 检查第一个token是否是shell的内置命令，如果是则直接调用运行。 如果不是内置命令，则按照第一个token的路径查找可执行文件，并将其它token作为参数运行。 如果最后一个token不是“&”，则该条命令在前台运行，shell将会阻塞等待程序终止或停止，并输出程序的输出。如果最后一个是“&”，则执行后shell将不会阻塞，直接进入等待下一条命令输入的状态。 6.3 hello的fork进程创建过程 在收到执行hello的命令后，shell调用fork函数创建了一个新的进程。调用fork函数的shell进程就是父进程，产生的新进程称为子进程。并且fork函数从两个进程中分别返回，父进程中返回的是子进程的进程id，子进程中返回的是0。接着两个进程互不干扰地继续执行。 在早期的Linux系统中，fork一个进程是将该进程的所有内存复制产生一个新的内存映像。由于这种方式比较浪费内存，在现在的操作系统中，fork刚执行后并不会直接复制父进程的所有内存，子进程的代码段、数据段、堆栈都暂时指向父进程的页表，即两个的虚拟空间不同，但是物理空间是同一个。当父进程或子进程有修改段段行为发生时，再为子进程的段分配空间，直到子进程执行exec函数之前，代码段都是和父进程共享的。执行exec函数后，子进程和父进程就拥有了完全分离的两个物理空间，子进程独立地执行新的代码段。这种技术被称为写时复制技术。 6.4 hello的execve过程 被fork出的子进程执行execve函数，进程陷入内核模式，用以访问hello的可执行目标文件。进程先执行一些必要的安全检查，读取hello开头的128个字节的ELF头（X86架构的Linux）以获取该程序的基本信息，接着将可执行文件映射到当前进程的进程空间中，并覆盖掉原来的进程数据，由于之前与当前进程的父进程共享代码段，此时就会在物理内存中为代码段分配空间。进程将EIP段值设置为新的可执行程序的入口地址，如果可执行程序是静态链接的程序，或不需要其他的动态链接库，则新的入口地址就是新的可执行文件的main函数地址；如果可执行程序还需要其他的动态链接库，则入口地址是链接器ld的入口地址。最后返回用户模式，CPU从新的EIP的地址中取指执行，即hello开始执行。至此，老进程的上下文已经完全被新的进程替代，但依然保有原来的进程ID。 6.5 hello的进程执行 进程时间片是为了进行进程调度而产生的概念。每个进程被分配给一个时间段，成为其时间片，也就是该进程允许运行的时间，如果在属于该进程的时间片结束时该进程依然在运行，则CPU将被剥夺并分配给另一个进程，如果进程在时间片结束前阻塞或结束，则CPU立刻进行切换。而进程调度所需要做的，仅仅是维护一个进程时间片队列，当一个进程用完其时间片后，它的时间片将被移到队列尾。当hello开始执行一段时间后，其时间片结束，CPU将切换到另一个进程运行。为了在切换回该进程时能够接着上次运行的地方继续运行，内核需要保存进程的一些寄存器的值、堆栈等，这些组成了进程的进程上下文。进程的切换实质上是进程上下文的切换。就这样hello与其它进程交替执行，交替占用CPU，直到hello进程结束。 一般来说，一个进程可以在两种状态下执行，用户模式（用户态）和内核模式（内核态），内核模式的权限高于用户模式的权限。进程每次调用一个系统调用时，进程的运行方式都发生变化：从用户模式切换到内核模式，然后继续执行。当出现系统调用或者发生异常（异常处理程序）时，进程就会从用户态切换回内核态。如果一个进程进入内核模式，那么那个进程就不会被进程调度切换，而会一直占有CPU，直到该进程终止或退出内核模式准备进入用户模式。 进程hello可能会由于用户按下ctrl+z或者ctrl+c向进程发送信号进入内核模式，或者出现缺页异常而进入内核模式，启动异常处理程序，如果是ctrl+z引发异常，异常处理程序将挂起（停止）hello进程，接着进行进程调度切换至其它进程。如果是ctrl+c，异常处理程序将直接终止进程。如果产生缺页异常，异常处理程序将进行系统调用，在磁盘（固态硬盘）上读取相应的虚拟页，并将其装入内存，在从内核模式退出时，将进行系统进程调度，切换到其它进程，当再次切换回hello时，将从上次导致缺页异常的地方再次执行，这次则不会引发缺页异常，进程正常地执行下去。 6.6 hello的异常与信号处理 在hello执行的时候按下ctrl+c，截图如下： 按下ctrl+c后，使用ps命令可以看出，hello进程已完全终止。 当用户按下ctrl+c后，shell进程通过内核向hello进程发送SIGINT信号，hello进程捕获到了这个信号后，陷入内核模式，由于没有指定信号处理程序，进程将启动默认的处理程序，处理程序执行默认动作，终止hello进程。 在hello执行的时候按下ctrl+z，截图如下： 显示出进程hello已经被停止，进程id为28805。当用户按下ctrl+z后，内核向进程发送SIGTSTP信号，该信号的默认动作是将当前运行在前台的进程挂起（停止）。 此时使用命令ps -a | grep hello，显示如下： 显示出进程id，hello进程名标红表示该进程已停止。 输入命令jobs -l，其中-l表示显示作业的进程id，显示如下： 该命令表示显示后台的所有工作，可以看到当前后台仅有一个工作hello，且suspended表示停止（挂起）状态。“+”表示这是最近一个放入后台的工作。 pstree命令可以以树状图的形式显示进程间的关系，由于进程树过大，只能截取部分： 可以看到，hello进程的从属关系为： system => system => gnome-terminal => zsh => hello 其中，system是所有进程的祖先进程。 使用fg命令加上作业id，可以将该进程转为前台进程并继续执行，输入fg %1，如下： 作业继续执行（continued）。 在进程挂起（suspended）时，使用kill命令，给进程发送信号9，可终止目标进程，如下： 显示进程已被终止（killed），再使用ps命令时则查看不到该进程，说明该进程确实以终止。kill -9 \\命令向进程发送信号9，即SIGKILL，该信号的默认处理动作是直接终止进程。 hello进程执行时还可能引发缺页异常，该异常是由虚拟地址所在的虚拟页映射的物理页没有在内存中分配导致的。当发生这个异常时，进程将陷入内核模式，启动缺页异常的对应处理程序。内核将找到引发异常的虚拟页，并将其写入物理内存中，并退出处理程序。进程将再次执行上次发生缺页异常的代码。 ​ 异常与信号处理： 当进程发生异常时，会陷入内核模式，如果没有事先设定好处理程序的话，执行对应的默认异常处理程序，进行默认处理动作，从处理程序返回后，进程有可能接着运行，也有可能重新运行导致异常产生的代码，也有可能终止或挂起。由于信号属于中断，是一种异常，所以处理的过程相似。 6.7 本章小结 进程的概念是当代计算机最重要的概念之一，它使多任务同时运行成为可能。每一个进程都如同独占CPU和内存一般，保证了运行的连贯性和结果一致性。异常和信号机制使我们可以灵活地调度协调各个各个进程。 "},"chapter7.html":{"url":"chapter7.html","title":"第七章 HELLO存储管理","keywords":"","body":""},"chapter8.html":{"url":"chapter8.html","title":"第八章 HELLO的IO管理","keywords":"","body":""},"conclusion.html":{"url":"conclusion.html","title":"结论","keywords":"","body":""},"attachment.html":{"url":"attachment.html","title":"附件","keywords":"","body":""},"reference.html":{"url":"reference.html","title":"参考文献","keywords":"","body":""}}